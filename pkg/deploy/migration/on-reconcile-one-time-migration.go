// Copyright (c) 2021 Red Hat, Inc.
// This program and the accompanying materials are made
// available under the terms of the Eclipse Public License 2.0
// which is available at https://www.eclipse.org/legal/epl-2.0/
//
// SPDX-License-Identifier: EPL-2.0
//
// Contributors:
//   Red Hat, Inc. - initial API and implementation
//

package migration

import (
	"context"
	"fmt"
	"reflect"
	"time"

	"github.com/eclipse-che/che-operator/pkg/deploy"
	"github.com/eclipse-che/che-operator/pkg/util"
	"github.com/sirupsen/logrus"
	corev1 "k8s.io/api/core/v1"
	"k8s.io/apimachinery/pkg/api/errors"
	"k8s.io/apimachinery/pkg/labels"
	"k8s.io/apimachinery/pkg/selection"
	"k8s.io/apimachinery/pkg/types"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/reconcile"
)

const (
	gitSelfSignedCertsConfigMapName = "che-git-self-signed-cert"
)

type Migrator struct {
	deploy.Reconcilable

	migrationDone bool
}

func NewMigrator() *Migrator {
	return &Migrator{
		migrationDone: false,
	}
}

func (m *Migrator) Reconcile(ctx *deploy.DeployContext) (reconcile.Result, bool, error) {
	if m.migrationDone {
		return reconcile.Result{}, true, nil
	}

	done, err := m.migrate(ctx)
	if done && err == nil {
		m.migrationDone = true
		// Give some time for the migration resources to be flushed and rerun reconcile
		return reconcile.Result{RequeueAfter: 5 * time.Second}, false, err
	}
	return reconcile.Result{}, done, err
}

func (m *Migrator) Finalize(ctx *deploy.DeployContext) error {
	return nil
}

func (m *Migrator) migrate(ctx *deploy.DeployContext) (bool, error) {
	if err := addRequiredLabelsForConfigMaps(ctx); err != nil {
		return false, err
	}

	if err := addRequiredLabelsForSecrets(ctx); err != nil {
		return false, err
	}

	if err := addRequiredLabelsForPartOfCheObjects(ctx); err != nil {
		return false, err
	}

	return true, nil
}

// addRequiredLabelsForConfigMaps processes the following cofig maps:
// - 'che-git-self-signed-cert' if spec.server.gitSelfSignedCert is set to true
// - spec.server.serverTrustStoreConfigMapName (legacy way to add trusted CA certificates)
func addRequiredLabelsForConfigMaps(ctx *deploy.DeployContext) error {
	// Legacy config map with additional CA certificates
	if ctx.CheCluster.Spec.Server.ServerTrustStoreConfigMapName != "" {
		if err := addRequiredLabelsForConfigMap(ctx, ctx.CheCluster.Spec.Server.ServerTrustStoreConfigMapName); err != nil {
			return err
		}
	}

	// Config map with CA certificates for git
	if ctx.CheCluster.Spec.Server.GitSelfSignedCert {
		if err := addRequiredLabelsForConfigMap(ctx, gitSelfSignedCertsConfigMapName); err != nil {
			return err
		}
	}

	return nil
}

// addRequiredLabelsForSecrets processes the following secrets:
// - spec.k8s.tlsSecretName
// - 'self-signed-certificate' secret
// - spec.server.cheHostTLSSecret
// - spec.server.proxySecret
// - spec.database.chePostgresSecret
// - spec.auth.identityProviderSecret
// - spec.auth.identityProviderPostgresSecret
// - spec.auth.oAuthSecret
// Note, most of the secrets above are autogenerated and do not require any migraation,
// but to handle the case when some were created manually, the check is done here.
func addRequiredLabelsForSecrets(ctx *deploy.DeployContext) error {
	if !util.IsOpenShift {
		// Kubernetes only

		tlsSecretName := deploy.DefaultCheTLSSecretName
		if ctx.CheCluster.Spec.K8s.TlsSecretName != "" {
			tlsSecretName = ctx.CheCluster.Spec.K8s.TlsSecretName
		}
		if err := addRequiredLabelsForSecret(ctx, tlsSecretName); err != nil {
			return err
		}
	}

	// TLS
	if err := addRequiredLabelsForSecret(ctx, deploy.CheTLSSelfSignedCertificateSecretName); err != nil {
		return err
	}

	if ctx.CheCluster.Spec.Server.CheHostTLSSecret != "" {
		if err := addRequiredLabelsForSecret(ctx, ctx.CheCluster.Spec.Server.CheHostTLSSecret); err != nil {
			return err
		}
	}

	// Proxy credentials
	if ctx.CheCluster.Spec.Server.ProxySecret != "" {
		if err := addRequiredLabelsForSecret(ctx, ctx.CheCluster.Spec.Server.ProxySecret); err != nil {
			return err
		}
	}

	// Database credentials
	if ctx.CheCluster.Spec.Database.ChePostgresSecret != "" {
		if err := addRequiredLabelsForSecret(ctx, ctx.CheCluster.Spec.Database.ChePostgresSecret); err != nil {
			return err
		}
	}

	// Keycloak related secrets
	if ctx.CheCluster.Spec.Auth.IdentityProviderSecret != "" {
		if err := addRequiredLabelsForSecret(ctx, ctx.CheCluster.Spec.Auth.IdentityProviderSecret); err != nil {
			return err
		}
	}

	if ctx.CheCluster.Spec.Auth.IdentityProviderPostgresSecret != "" {
		if err := addRequiredLabelsForSecret(ctx, ctx.CheCluster.Spec.Auth.IdentityProviderPostgresSecret); err != nil {
			return err
		}
	}

	// OAuth
	if ctx.CheCluster.Spec.Auth.OAuthSecret != "" {
		if err := addRequiredLabelsForSecret(ctx, ctx.CheCluster.Spec.Auth.OAuthSecret); err != nil {
			return err
		}
	}

	return nil
}

func addRequiredLabelsForConfigMap(ctx *deploy.DeployContext, configMapName string) error {
	configMap := &corev1.ConfigMap{}
	return addRequiredLabelsForObject(ctx, configMapName, configMap)
}

func addRequiredLabelsForSecret(ctx *deploy.DeployContext, secretName string) error {
	secret := &corev1.Secret{}
	return addRequiredLabelsForObject(ctx, secretName, secret)
}

// addRequiredLabelsForObject adds required label to the object with given name to be cached by operator's k8s client.
// As the function doesn't know the kind of the object with given name an empty object should be passed,
// for example: addRequiredLabelsForObject(ctx, "my-secret", &corev1.Secret{})
func addRequiredLabelsForObject(ctx *deploy.DeployContext, objectName string, obj client.Object) error {
	// Check if the object is already migrated
	if exists, _ := deploy.GetNamespacedObject(ctx, objectName, obj); exists {
		// Default client sees the object in cache, no need in adding labels
		return nil
	}

	err := ctx.ClusterAPI.NonCachingClient.Get(context.TODO(), types.NamespacedName{Namespace: ctx.CheCluster.Namespace, Name: objectName}, obj)
	if err != nil {
		if errors.IsNotFound(err) {
			// The object doesn't exist in cluster, nothing to do
			return nil
		}
		return err
	}

	// Add required labels to the object
	labels := obj.GetLabels()
	if labels == nil {
		labels = make(map[string]string)
	}
	labels[deploy.KubernetesInstanceLabelKey] = deploy.DefaultCheFlavor(ctx.CheCluster)
	obj.SetLabels(labels)
	if err := ctx.ClusterAPI.NonCachingClient.Update(context.TODO(), obj); err != nil {
		return err
	}

	return nil
}

// addRequiredLabelsForPartOfCheObjects searches for secrets and config maps label in Che installation namespace,
// that have 'app.kubernetes.io/part-of=che' label.
// When such a resource is found, a standard set of labels is added to the resource to have it cached by the Operator client.
func addRequiredLabelsForPartOfCheObjects(ctx *deploy.DeployContext) error {
	cheFlavor := deploy.DefaultCheFlavor(ctx.CheCluster)

	// Prepare selector for all part-of objects in the installation namespace
	partOfCheSelectorRequirement, err := labels.NewRequirement(deploy.KubernetesPartOfLabelKey, selection.Equals, []string{deploy.CheEclipseOrg})
	if err != nil {
		logrus.Error(getFailedToCreateSelectorErrorMessage())
		return err
	}
	instanceNotCheFlavorSelectorRequirement, err := labels.NewRequirement(deploy.KubernetesInstanceLabelKey, selection.NotEquals, []string{cheFlavor})
	if err != nil {
		logrus.Error(getFailedToCreateSelectorErrorMessage())
		return err
	}
	objectsToMigrateLabelSelector := labels.NewSelector().Add(*partOfCheSelectorRequirement).Add(*instanceNotCheFlavorSelectorRequirement)
	listOptions := &client.ListOptions{
		LabelSelector: objectsToMigrateLabelSelector,
		Namespace:     ctx.CheCluster.GetNamespace(),
	}

	// Migrate all config maps with part-of che label
	configMapsList := &corev1.ConfigMapList{}
	if err = ctx.ClusterAPI.NonCachingClient.List(context.TODO(), configMapsList, listOptions); err != nil {
		logrus.Warn(getFailedToGetErrorMessageFor("Config Maps"))
		return err
	}
	if configMapsList.Items != nil {
		for _, cm := range configMapsList.Items {
			cm.ObjectMeta.Labels[deploy.KubernetesInstanceLabelKey] = cheFlavor
			if err := ctx.ClusterAPI.NonCachingClient.Update(context.TODO(), &cm); err != nil {
				logrus.Warn(getFailedToUpdateErrorMessage(cm.GetName(), reflect.TypeOf(cm).Name()))
				return err
			}
		}
	}

	// Migrate all secrets with part-of che label
	secretsList := &corev1.SecretList{}
	if err = ctx.ClusterAPI.NonCachingClient.List(context.TODO(), secretsList, listOptions); err != nil {
		logrus.Warn(getFailedToGetErrorMessageFor("Secrets"))
		return err
	}
	if secretsList.Items != nil {
		for _, secret := range secretsList.Items {
			secret.ObjectMeta.Labels[deploy.KubernetesInstanceLabelKey] = cheFlavor
			if err := ctx.ClusterAPI.NonCachingClient.Update(context.TODO(), &secret); err != nil {
				logrus.Warn(getFailedToUpdateErrorMessage(secret.GetName(), reflect.TypeOf(secret).Name()))
				return err
			}
		}
	}

	return nil
}

func getFailedToGetErrorMessageFor(item string) string {
	return fmt.Sprintf("Failed to get %s to add %s label. This resources will be ignored by Operator.",
		item, deploy.KubernetesInstanceLabelKey)
}

func getFailedToUpdateErrorMessage(objectName string, objectKind string) string {
	return fmt.Sprintf("Failed to update %s '%s' with label %s. This resource will be ignored by Operator.",
		objectKind, objectName, deploy.KubernetesInstanceLabelKey)
}

func getFailedToCreateSelectorErrorMessage() string {
	return "Failed to create selector for resources migration. Unable to perform resources migration."
}
