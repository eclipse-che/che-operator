// Copyright (c) 2021 Red Hat, Inc.
// This program and the accompanying materials are made
// available under the terms of the Eclipse Public License 2.0
// which is available at https://www.eclipse.org/legal/epl-2.0/
//
// SPDX-License-Identifier: EPL-2.0
//
// Contributors:
//   Red Hat, Inc. - initial API and implementation
//

package migration

import (
	"context"
	"time"

	"github.com/eclipse-che/che-operator/pkg/deploy"
	"github.com/eclipse-che/che-operator/pkg/util"
	"k8s.io/apimachinery/pkg/api/errors"
	"k8s.io/apimachinery/pkg/types"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/reconcile"
)

const (
	gitSelfSignedCertsConfigMapName = "che-git-self-signed-cert"
)

type Migrator struct {
	deploy.Reconcilable

	migrationDone bool
}

func NewMigrator() *Migrator {
	return &Migrator{
		migrationDone: false,
	}
}

func (m *Migrator) Reconcile(ctx *deploy.DeployContext) (reconcile.Result, bool, error) {
	if m.migrationDone {
		return reconcile.Result{}, true, nil
	}

	result, done, err := m.migrate(ctx)
	m.migrationDone = done && err == nil
	return result, done, err
}

func (m *Migrator) Finalize(ctx *deploy.DeployContext) error {
	return nil
}

func (m *Migrator) migrate(ctx *deploy.DeployContext) (reconcile.Result, bool, error) {
	if err := addRequiredLabelsForConfigMaps(ctx); err != nil {
		return reconcile.Result{}, false, err
	}

	if err := addRequiredLabelsForSecrets(ctx); err != nil {
		return reconcile.Result{}, false, err
	}

	// Give some time for the migration resources to be flushed
	return reconcile.Result{RequeueAfter: 5 * time.Second}, true, nil
}

// addRequiredLabelsForConfigMaps processes the following cofig maps:
// - 'che-git-self-signed-cert' if spec.server.gitSelfSignedCert is set to true
// - spec.server.serverTrustStoreConfigMapName (legacy way to add trusted CA certificates)
func addRequiredLabelsForConfigMaps(ctx *deploy.DeployContext) error {
	// Legacy config map with additional CA certificates
	if ctx.CheCluster.Spec.Server.ServerTrustStoreConfigMapName != "" {
		if err := addRequiredLabelsForObject(ctx, ctx.CheCluster.Spec.Server.ServerTrustStoreConfigMapName, deploy.CheCACertsConfigMapLabelValue); err != nil {
			return err
		}
	}

	// Config map with CA certificates for git
	if ctx.CheCluster.Spec.Server.GitSelfSignedCert {
		if err := addRequiredLabelsForObject(ctx, gitSelfSignedCertsConfigMapName, deploy.CheCACertsConfigMapLabelValue); err != nil {
			return err
		}
	}

	return nil
}

// addRequiredLabelsForSecrets processes the following secrets:
// - spec.k8s.tlsSecretName
// - 'self-signed-certificate' secret
// - spec.server.cheHostTLSSecret
// - spec.server.proxySecret
// - spec.database.chePostgresSecret
// - spec.auth.identityProviderSecret
// - spec.auth.identityProviderPostgresSecret
// - spec.auth.oAuthSecret
// Note, most of the secrets above are autogenerated and do not require any migraation,
// but to handle the case when some were created manually, the check is done here.
func addRequiredLabelsForSecrets(ctx *deploy.DeployContext) error {
	if !util.IsOpenShift {
		// Kubernetes only

		tlsSecretName := "che-tls"
		if ctx.CheCluster.Spec.K8s.TlsSecretName != "" {
			tlsSecretName = ctx.CheCluster.Spec.K8s.TlsSecretName
		}
		if err := addRequiredLabelsForObject(ctx, tlsSecretName, cheFlavor); err != nil {
			return err
		}
	}

	// TLS
	if err := addRequiredLabelsForObject(ctx, deploy.CheTLSSelfSignedCertificateSecretName, cheFlavor); err != nil {
		return err
	}

	if ctx.CheCluster.Spec.Server.CheHostTLSSecret != "" {
		if err := addRequiredLabelsForObject(ctx, ctx.CheCluster.Spec.Server.CheHostTLSSecret, cheFlavor); err != nil {
			return err
		}
	}

	// Proxy credentials
	if ctx.CheCluster.Spec.Server.ProxySecret != "" {
		if err := addRequiredLabelsForObject(ctx, ctx.CheCluster.Spec.Server.ProxySecret, cheFlavor); err != nil {
			return err
		}
	}

	// Database credentials
	if ctx.CheCluster.Spec.Database.ChePostgresSecret != "" {
		if err := addRequiredLabelsForObject(ctx, ctx.CheCluster.Spec.Database.ChePostgresSecret, cheFlavor); err != nil {
			return err
		}
	}

	// Keycloak related secrets
	if ctx.CheCluster.Spec.Auth.IdentityProviderSecret != "" {
		if err := addRequiredLabelsForObject(ctx, ctx.CheCluster.Spec.Auth.IdentityProviderSecret, cheFlavor); err != nil {
			return err
		}
	}

	if ctx.CheCluster.Spec.Auth.IdentityProviderPostgresSecret != "" {
		if err := addRequiredLabelsForObject(ctx, ctx.CheCluster.Spec.Auth.IdentityProviderPostgresSecret, cheFlavor); err != nil {
			return err
		}
	}

	// OAuth
	if ctx.CheCluster.Spec.Auth.OAuthSecret != "" {
		if err := addRequiredLabelsForObject(ctx, ctx.CheCluster.Spec.Auth.OAuthSecret, cheFlavor); err != nil {
			return err
		}
	}

	return nil
}

func addRequiredLabelsForObject(ctx *deploy.DeployContext, objectName string, componentName string) error {
	// Check if the object is already migrated
	var obj client.Object
	if exists, _ := deploy.GetNamespacedObject(ctx, objectName, obj); exists {
		// Default client sees the object in cache, no need in adding labels
		return nil
	}

	err := ctx.ClusterAPI.NonCachingClient.Get(context.TODO(), types.NamespacedName{Namespace: ctx.CheCluster.Namespace, Name: objectName}, obj)
	if err != nil {
		if errors.IsNotFound(err) {
			// The object doesn't exist in cluster, nothing to do
			return nil
		}
		return err
	}

	// Add required labels to the object
	labels := obj.GetLabels()
	if labels == nil {
		labels = make(map[string]string)
	}
	for labelName, labelValue := range deploy.GetLabels(ctx.CheCluster, componentName) {
		labels[labelName] = labelValue
	}
	obj.SetLabels(labels)
	if err := ctx.ClusterAPI.NonCachingClient.Update(context.TODO(), obj); err != nil {
		return err
	}

	return nil
}
